---
path: 'docs/dev-guide/widget-system-architecture.mdx'
title: 'Widget System Architecture'
description: 'Complete guide to SveltyCMS widget architecture using the Three Pillars pattern, factory functions, registry, and MDX documentation per widget.'
order: 8
icon: 'mdi:widgets'
author: 'admin'
created: '2025-01-15'
updated: '2025-01-15'
tags:
  - 'widgets'
  - 'architecture'
  - 'factory-pattern'
  - 'three-pillars'
  - 'mdsvex'
  - 'valibot'
---

# Widget System Architecture

## Overview

SveltyCMS uses a modern, type-safe widget architecture based on the **Three Pillars** pattern: **Definition**, **Input**, and **Display**. The widget system is built around factory functions, a centralized registry, and comprehensive validation using Valibot.

### Key Features

- **Three Pillars Architecture**: Separation of Definition, Input, and Display components
- **Factory Pattern**: Type-safe widget creation with `createWidget()`
- **Centralized Registry**: Single source of truth for widget management
- **Valibot Validation**: Declarative, type-safe data validation
- **MDX Documentation**: Each widget has its own `.mdx` documentation file
- **Core/Custom Separation**: Distinction between essential and optional widgets
- **Dynamic Loading**: Code splitting with import.meta.glob
- **Dependency Management**: Widget dependencies tracked and validated

---

## Widget System Core Files

### 1. `src/widgets/factory.ts`

**Purpose**: Type-safe widget factory for creating widget definitions and field instances.

**What it does**:

- Provides `createWidget<TProps>()` function for defining widgets
- Ensures type safety using TypeScript generics
- Implements the Three Pillars architecture pattern
- Combines widget defaults with field-specific configuration
- Attaches metadata for system compatibility

**Key Types**:

```typescript
// Widget definition configuration
interface WidgetConfig<TProps> {
	Name: string;
	Icon?: string;
	Description?: string;
	inputComponentPath?: string;        // Path to Input.svelte
	displayComponentPath?: string;      // Path to Display.svelte
	defaults?: Partial<TProps>;         // Widget-specific defaults
	validationSchema: ValibotSchema | ((field: FieldInstance) => ValibotSchema);
	GuiSchema?: Record<string, unknown>;
	GraphqlSchema?: (...) => {...};
	aggregations?: {...};
}

// Field instance configuration
type FieldConfig<TProps> = {
	label: string;
	db_fieldName?: string;
	required?: boolean;
	translated?: boolean;
	width?: number;
	helper?: string;
	permissions?: Record<string, Record<string, boolean>>;
} & Partial<TProps>;  // Widget-specific props
```

**Usage Example**:

```typescript
import { createWidget } from '@src/widgets/factory';
import { boolean } from 'valibot';
import type { CheckboxProps } from './types';

const CheckboxWidget = createWidget<CheckboxProps>({
	Name: 'Checkbox',
	Icon: 'tabler:checkbox',
	Description: 'A simple boolean toggle field',

	// Three Pillars: paths to components
	inputComponentPath: '/src/widgets/core/checkbox/Input.svelte',
	displayComponentPath: '/src/widgets/core/checkbox/Display.svelte',

	// Valibot validation
	validationSchema: boolean('Must be a boolean.'),

	// Widget-specific defaults
	defaults: {
		color: 'primary',
		size: 'md',
		translated: false
	},

	// GuiSchema for collection builder
	GuiSchema: {
		label: { widget: Input, required: true },
		required: { widget: Toggles, required: false }
		// ... more GUI fields
	}
});

export default CheckboxWidget;
```

**Three Pillars Implementation**:

1. **Definition** (`createWidget`): Defines the widget's blueprint
2. **Input** (`Input.svelte`): Interactive component for editing
3. **Display** (`Display.svelte`): Lightweight component for viewing

---

### 2. `src/widgets/index.ts`

**Purpose**: Main entry point for the widget system. Handles initialization, loading, and registration.

**What it does**:

- Dynamically imports all widgets from `core/` and `custom/` directories
- Creates widget functions with unique IDs
- Checks widget dependencies
- Registers widgets in the central registry
- Manages widget activation status
- Provides reactive stores for widget state
- Exports widgets globally for system access

**Key Functions**:

```typescript
// Initialize all widgets from file system
export async function initializeWidgets(): Promise<void>;

// Ensure widgets are initialized (idempotent)
export async function ensureWidgetsInitialized(): Promise<void>;

// Check if widget dependencies are met
function checkDependencies(widget: WidgetFunction): boolean;

// Create widget function from module
function createWidgetFunction(widgetModule: WidgetModule, name: string): WidgetFunction;
```

**Widget Loading Process**:

1. **Import**: Load core and custom widget modules using `import.meta.glob`
2. **Validate**: Check module structure and extract widget name
3. **Sort**: Load core widgets first, then custom widgets alphabetically
4. **Create**: Create widget functions with unique IDs
5. **Dependencies**: Validate widget dependencies
6. **Register**: Add to widget functions map and registry
7. **Activate**: Load activation status from database
8. **Global**: Make widgets available globally

**Example Output**:

```
‚ö° 10 core widgets loaded: Checkbox, Date, DateRange, Input, MediaUpload, Radio, Relation, RichText, ...
üì¶ 3 custom widgets loaded: SEO, ColorPicker, Rating
üöÄ All 13 widgets loaded Successfully in 45.32ms
```

**Reactive Stores**:

```typescript
// Map of all widget functions
export const widgetFunctions = store<Map<string, WidgetFunction>>(new Map());

// Set of active widget names
const activeWidgetList = store<Set<string>>(new Set());
```

---

### 3. `src/widgets/registry.ts`

**Purpose**: Centralized widget registry to avoid circular dependencies.

**What it does**:

- Maintains a global Map of all registered widgets
- Provides safe access to widget instances
- Prevents circular dependency issues
- Allows querying widget availability
- Supports testing with registry clearing

**API**:

```typescript
// Register a widget
export function registerWidget(widget: Widget): void;

// Get a widget by name
export function getWidget(name: string): Widget | undefined;

// Get all registered widgets
export function getAllWidgets(): Record<string, Widget>;

// Get all widget names
export function getWidgetNames(): string[];

// Check if widget exists
export function hasWidget(name: string): boolean;

// Clear registry (testing)
export function clearRegistry(): void;
```

**Usage Example**:

```typescript
import { registerWidget, getWidget, hasWidget } from '@widgets/registry';

// Register during initialization
registerWidget({
	__widgetId: 'unique-id-123',
	Name: 'Checkbox',
	dependencies: [],
	validateWidget: () => Promise.resolve(null),
	updateTranslationStatus: () => {}
});

// Check availability
if (hasWidget('Checkbox')) {
	const widget = getWidget('Checkbox');
	console.log('Widget found:', widget.Name);
}
```

**Why a Registry?**

- **Circular Dependencies**: Widgets can reference other widgets without import cycles
- **Runtime Lookup**: Dynamic widget resolution at runtime
- **Testing**: Easy to mock and reset widget state
- **Single Source of Truth**: One place to check widget availability

---

### 4. `src/widgets/types.ts`

**Purpose**: TypeScript type definitions for the widget system.

**What it does**:

- Defines core widget types and interfaces
- Provides type safety across the widget system
- Documents expected widget structure
- Supports IDE autocomplete and type checking

**Key Types**:

```typescript
// Widget activation status
export type WidgetStatus = 'active' | 'inactive';

// Widget instance (registered in registry)
export interface Widget {
	__widgetId: string;
	Name: string;
	dependencies?: string[];
	component?: typeof SvelteComponent;
	config?: Record<string, unknown>;
	validateWidget: () => Promise<string | null>;
	updateTranslationStatus: (value: unknown, field: Field, language: string) => void;
	modifyRequest?: (args: ModifyRequestParams) => Promise<Record<string, unknown>>;
	GuiFields?: unknown;
	Icon?: string;
	Description?: string;
	aggregations?: unknown;
}

// Widget constructor function
export interface WidgetFunction {
	(config: Record<string, unknown>): Field;
	componentPath: string;
	Name?: string;
	GuiSchema?: Record<string, GuiFieldConfig>;
	GraphqlSchema?: GraphqlSchema;
	Icon?: string;
	Description?: string;
	aggregations?: unknown;
	modifyRequest?: (args: ModifyRequestParams) => Promise<Record<string, unknown>>;
	dependencies?: string[];
	toString?: () => string;
	__widgetId?: string;
	__isCore?: boolean;
}

// Widget module (imported from index.ts)
export interface WidgetModule {
	default: WidgetFunction;
}

// Widget placeholder (for lazy loading)
export interface WidgetPlaceholder {
	__widgetId: string;
	__widgetName: string;
	__widgetConfig: Record<string, unknown>;
}
```

**Usage in Widget Development**:

```typescript
import type { Widget, WidgetFunction, WidgetModule } from '@widgets/types';

// Type-safe widget function
const myWidget: WidgetFunction = createWidget<MyProps>({
	// ... configuration
});

// Type-safe widget instance
const widgetInstance: Widget = {
	__widgetId: uuidv4(),
	Name: 'MyWidget',
	validateWidget: () => Promise.resolve(null),
	updateTranslationStatus: () => {}
};
```

---

### 5. `src/widgets/MissingWidget.svelte`

**Purpose**: Fallback component displayed when a widget is missing or disabled.

**What it does**:

- Renders a warning when a widget cannot be found
- Shows widget name that was requested
- Provides visual feedback with orange warning styling
- Prevents application crashes from missing widgets
- Helps developers identify configuration issues

**Component**:

```svelte
<script lang="ts">
	let { config } = $props();
</script>

<div class="rounded-md border border-orange-200 bg-orange-50 p-4 text-orange-700">
	<p>
		‚ö†Ô∏è Widget "{config.Name}" is missing or disabled.
	</p>
</div>
```

**When It Appears**:

- Widget referenced in collection schema but not registered
- Widget is disabled in system settings
- Widget failed to load due to import error
- Typo in widget name

**Example**:

```typescript
// Collection references widget that doesn't exist
fields: [
	widgets.NonExistentWidget({
		// This widget doesn't exist
		label: 'My Field'
	})
];
// Results in: ‚ö†Ô∏è Widget "NonExistentWidget" is missing or disabled.
```

---

### 6. `src/widgets/widgetManager.svelte.ts`

**Purpose**: Legacy compatibility layer and additional widget management utilities.

**What it does**:

- Provides backward compatibility with old widget API
- Bridges new store-based system with legacy code
- Implements additional widget utilities
- Supports gradual migration to new architecture

**Key Functions** (from earlier exploration):

```typescript
// Resolve widget placeholder to actual widget
export async function resolveWidgetPlaceholder(placeholder: { widget: string; config: Record<string, unknown> });

// Check widget availability
export function isWidgetAvailable(widgetName: string): boolean;

// Get all widgets
export function getWidgets();

// Get active widgets
export function getActiveWidgets();

// Update widget status
export async function updateWidgetStatus(widgetName: string, status: WidgetStatus): Promise<void>;

// Get widget config
export function getWidgetConfig(widgetName: string): Record<string, unknown> | undefined;

// Update widget config
export async function updateWidgetConfig(widgetName: string, config: Record<string, unknown>): Promise<void>;

// Load widgets
export async function loadWidgets(): Promise<Record<string, Widget>>;
```

## Widget Structure

Each widget follows a consistent directory structure:

```
src/widgets/
‚îú‚îÄ‚îÄ core/                           # Core widgets (always enabled)
‚îÇ   ‚îú‚îÄ‚îÄ checkbox/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts               # Widget definition (factory)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts               # Widget-specific types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.svelte           # Input component (editing)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Display.svelte         # Display component (viewing)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ checkbox.mdx           # Widget documentation
‚îÇ   ‚îú‚îÄ‚îÄ input/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.svelte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Display.svelte
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ input.mdx
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ custom/                         # Custom widgets (optional)
‚îÇ   ‚îú‚îÄ‚îÄ seo/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.svelte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Display.svelte
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seo.mdx
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ factory.ts                      # Widget factory
‚îú‚îÄ‚îÄ index.ts                        # Widget loader
‚îú‚îÄ‚îÄ registry.ts                     # Widget registry
‚îú‚îÄ‚îÄ types.ts                        # Widget types
‚îú‚îÄ‚îÄ widgetManager.svelte.ts         # Legacy compatibility
‚îî‚îÄ‚îÄ MissingWidget.svelte            # Fallback component
```

---

## Widget Documentation with MDX

### Why MDX?

Each widget in SveltyCMS has its own `.mdx` documentation file. We use **MDX** (Markdown with JSX/Svelte) because:

1. **Standard MDX Format**: Following industry-standard MDX conventions for documentation
2. **mdsvex Integration**: We use [mdsvex](https://mdsvex.pngwn.io/) for Svelte-compatible MDX support
3. **Interactive**: Can embed Svelte components in documentation
4. **Type-Safe**: Documentation lives next to code
5. **Maintainable**: Docs update with widget changes
6. **Discoverable**: Easy to find widget documentation

### MDX Documentation Structure

**File**: `src/widgets/core/checkbox/checkbox.mdx`

````mdx
---
path: 'src/widgets/core/checkbox/checkbox.mdx'
title: 'Checkbox Field'
description: 'A simple boolean toggle field used for true/false values in collections.'
order: 6
icon: 'tabler:checkbox'
author: 'admin'
created: '2025-09-29'
updated: '2025-09-29'
tags:
  - 'widget'
  - 'checkbox'
  - 'field'
  - 'boolean'
  - 'core'
---

# Checkbox Field

The Checkbox field provides a lightweight boolean toggle for binary options (true/false).

## Features

- Native boolean storage (true / false)
- Accessible markup and keyboard support
- Valibot validation (ensures boolean values)
- Fully configurable color and size options

## Usage (for Content Editors)

When editing content, the Checkbox appears as a simple toggle control.

## Example (Collection)

\```typescript
import widgets from '@widgets';

export const schema = {
	fields: [
		widgets.Checkbox({
			label: 'Featured',
			db_fieldName: 'featured',
			required: false,
			helper: 'Mark if this item should be featured',
			color: 'primary',
			size: 'md'
		})
	]
};
\```

## Configuration (Developer)

| Property       | Type    | Default   | Description               |
| -------------- | ------- | --------- | ------------------------- |
| `label`        | string  | ‚Äî         | Field label (required)    |
| `db_fieldName` | string  | derived   | Database field name       |
| `required`     | boolean | false     | Whether field must be set |
| `color`        | string  | 'primary' | Visual color accent       |
| `size`         | string  | 'md'      | Visual control size       |

## Data Structure & Validation

- Stored value: boolean (true / false)
- Validation (Valibot): `boolean('Must be a boolean.')`

## Accessibility

Uses semantic `input[type=checkbox]` with ARIA attributes.
````

### Documentation Sections

Each widget MDX file should include:

1. **Frontmatter**: Metadata (path, title, description, order, icon, author, dates, tags)
2. **Overview**: What the widget does
3. **Features**: Key capabilities
4. **Usage**: For content editors
5. **Example**: Code examples in collections
6. **Configuration**: Table of all properties
7. **Data Structure**: How data is stored and validated
8. **Accessibility**: A11y considerations
9. **Advanced**: Optional advanced features

### Using mdsvex

We use [mdsvex](https://mdsvex.pngwn.io/) to process standard MDX files with Svelte support.

**Installation** (if not already installed):

```bash
bun add -D mdsvex
```

**Configuration** (`svelte.config.js`):

```javascript
import { mdsvex } from 'mdsvex';

const config = {
	extensions: ['.svelte', '.mdx'],

	preprocess: [
		mdsvex({
			extensions: ['.mdx'],
			layout: {
				// Optional: layout for widget docs
				widgets: './src/layouts/WidgetDocLayout.svelte'
			}
		})
	]
};

export default config;
```

**Rendering Widget Documentation**:

```svelte
<!-- src/routes/docs/widgets/[widget]/+page.svelte -->
<script lang="ts">
	import { page } from '$app/stores';

	// Dynamically import widget MDX
	const widgetName = $page.params.widget;

	// Import MDX file
	import(`@widgets/core/${widgetName}/${widgetName}.mdx`).then((module) => {
		// Render MDX component
	});
</script>
```

---

## Creating a New Widget

### Step 1: Define Widget Types

**File**: `src/widgets/core/mywidget/types.ts`

```typescript
export interface MyWidgetProps {
	color?: 'primary' | 'secondary' | 'accent';
	size?: 'sm' | 'md' | 'lg';
	maxLength?: number;
}
```

### Step 2: Create Widget Definition

**File**: `src/widgets/core/mywidget/index.ts`

```typescript
import { createWidget } from '@src/widgets/factory';
import { string, minLength, maxLength, pipe } from 'valibot';
import type { MyWidgetProps } from './types';

// Valibot validation
const MyWidgetValidation = pipe(string('Must be a string'), minLength(1, 'Required'), maxLength(255, 'Too long'));

// Create widget
const MyWidget = createWidget<MyWidgetProps>({
	Name: 'MyWidget',
	Icon: 'mdi:text',
	Description: 'My custom widget',

	// Three Pillars
	inputComponentPath: '/src/widgets/core/mywidget/Input.svelte',
	displayComponentPath: '/src/widgets/core/mywidget/Display.svelte',

	// Validation
	validationSchema: MyWidgetValidation,

	// Defaults
	defaults: {
		color: 'primary',
		size: 'md',
		maxLength: 255
	},

	// GuiSchema
	GuiSchema: {
		label: { widget: Input, required: true },
		maxLength: { widget: Input, required: false }
		// ... more fields
	}
});

export default MyWidget;
```

### Step 3: Create Input Component

**File**: `src/widgets/core/mywidget/Input.svelte`

```svelte
<script lang="ts">
	import type { FieldType } from './index';

	let {
		field,
		value = $bindable()
	}: {
		field: FieldType;
		value: string;
	} = $props();

	const maxLength = field.maxLength ?? 255;
</script>

<div class="widget-input">
	<label for={field.db_fieldName}>{field.label}</label>
	<input id={field.db_fieldName} bind:value type="text" maxlength={maxLength} class="size-{field.size} color-{field.color}" />
	{#if field.helper}
		<p class="helper">{field.helper}</p>
	{/if}
</div>
```

### Step 4: Create Display Component

**File**: `src/widgets/core/mywidget/Display.svelte`

```svelte
<script lang="ts">
	import type { FieldType } from './index';

	let {
		field,
		value
	}: {
		field: FieldType;
		value: string;
	} = $props();
</script>

<div class="widget-display">
	<span class="value">{value || '‚Äî'}</span>
</div>
```

### Step 5: Write MDX Documentation

**File**: `src/widgets/core/mywidget/mywidget.mdx`

````mdx
---
path: 'src/widgets/core/mywidget/mywidget.mdx'
title: 'My Widget'
description: 'Custom widget for my specific use case'
order: 20
icon: 'mdi:text'
author: 'developer'
created: '2025-01-15'
updated: '2025-01-15'
tags:
  - 'widget'
  - 'custom'
  - 'core'
---

# My Widget

Description of what the widget does...

## Features

- Feature 1
- Feature 2

## Usage

\```typescript
widgets.MyWidget({
label: 'My Field',
maxLength: 100
})
\```

## Configuration

| Property    | Type   | Default | Description |
| ----------- | ------ | ------- | ----------- |
| `label`     | string | ‚Äî       | Field label |
| `maxLength` | number | 255     | Max length  |

## Validation

Uses Valibot validation with minLength and maxLength.
````

### Step 6: Widget Auto-Discovery

The widget will be automatically discovered and loaded by `src/widgets/index.ts`:

- ‚úÖ No need to register manually
- ‚úÖ Automatically assigned unique ID
- ‚úÖ Added to widget functions map
- ‚úÖ Registered in widget registry
- ‚úÖ Available in collections immediately

---

## Widget Dependencies

Widgets can depend on other widgets. Dependencies are declared in the widget definition:

```typescript
const SEOWidget = createWidget<SEOProps>({
	Name: 'SEO'
	// ... other config
});

// Add dependencies after creation
SEOWidget.dependencies = ['Input', 'RichText'];
```

**Dependency Checking**:

During initialization, `checkDependencies()` verifies all dependencies are available:

```typescript
function checkDependencies(widget: WidgetFunction): boolean {
	if (!widget.dependencies) return true;

	for (const dep of widget.dependencies) {
		if (!widgetFunctions().has(dep)) {
			logger.warn(`Widget ${widget.Name} missing dependency: ${dep}`);
			return false;
		}
	}
	return true;
}
```

**Loading Order**:

1. Core widgets load first
2. Custom widgets load second
3. Widgets with unmet dependencies are skipped
4. Warning logged for missing dependencies

---

## Valibot Validation

All widgets use [Valibot](https://valibot.dev/) for type-safe validation:

### Simple Validation

```typescript
import { boolean, string, number } from 'valibot';

// Boolean
const CheckboxValidation = boolean('Must be a boolean.');

// String
const InputValidation = string('Must be a string.');

// Number
const NumberValidation = number('Must be a number.');
```

### Advanced Validation

```typescript
import { pipe, string, minLength, maxLength, email, url } from 'valibot';

// String with constraints
const EmailValidation = pipe(string('Must be a string'), email('Invalid email format'));

// Multiple constraints
const InputValidation = pipe(string('Must be a string'), minLength(1, 'Required'), maxLength(255, 'Too long'));

// URL validation
const URLValidation = pipe(string('Must be a string'), url('Invalid URL format'));
```

### Dynamic Validation

Validation can access the field instance:

```typescript
const DynamicValidation = (field: FieldInstance) => {
	const max = field.maxLength ?? 255;
	return pipe(string('Must be a string'), maxLength(max, `Maximum ${max} characters`));
};

const MyWidget = createWidget({
	// ...
	validationSchema: DynamicValidation
});
```

### Validation Benefits

- **Type Safety**: TypeScript inference from validation schema
- **Runtime Checks**: Validation at runtime prevents invalid data
- **Clear Errors**: Descriptive error messages for users
- **Composable**: Pipe multiple validators together
- **Performance**: Fast validation with minimal overhead

---

## Best Practices

### 1. Follow Three Pillars

Always separate Definition, Input, and Display:

```
‚úÖ Good:
- index.ts (Definition)
- Input.svelte (Interactive)
- Display.svelte (View)

‚ùå Avoid:
- index.ts with inline components
- Single component for input and display
```

### 2. Use TypeScript Generics

Leverage generics for type safety:

```typescript
// ‚úÖ Good: Type-safe props
const MyWidget = createWidget<MyWidgetProps>({
	// TypeScript knows about MyWidgetProps
});

// ‚ùå Avoid: No type safety
const MyWidget = createWidget({
	// No autocomplete or type checking
});
```

### 3. Write Comprehensive MDX Docs

Every widget should have complete documentation:

- ‚úÖ Frontmatter with metadata
- ‚úÖ Overview and features
- ‚úÖ Usage examples
- ‚úÖ Configuration table
- ‚úÖ Validation details
- ‚úÖ Accessibility notes

### 4. Validate with Valibot

Use Valibot for all data validation:

```typescript
// ‚úÖ Good: Type-safe validation
import { string, minLength } from 'valibot';
validationSchema: pipe(string(), minLength(1))

// ‚ùå Avoid: Manual validation
validate(value) {
	if (!value) return 'Required';
}
```

### 5. Set Sensible Defaults

Provide defaults for optional properties:

```typescript
defaults: {
	color: 'primary',
	size: 'md',
	required: false
}
```

### 6. Handle Missing Widgets Gracefully

The system automatically shows `MissingWidget.svelte` for unavailable widgets. No need to add explicit error handling.

### 7. Use Dependency Declaration

Declare dependencies explicitly:

```typescript
MyWidget.dependencies = ['Input', 'RichText'];
```

### 8. Keep Components Simple

- **Input.svelte**: Focus on editing UX
- **Display.svelte**: Minimal, fast rendering
- Move complex logic to utility functions

---

## Migration Guide

### From Old Widget System

```typescript
// OLD: Manual widget definition
export const OldWidget = {
	Name: 'OldWidget',
	component: OldWidgetComponent,
	validate: (value) => { ... }
};

// NEW: Factory pattern with Valibot
import { createWidget } from '@widgets/factory';
import { string } from 'valibot';

const NewWidget = createWidget({
	Name: 'NewWidget',
	inputComponentPath: '/src/widgets/core/newwidget/Input.svelte',
	displayComponentPath: '/src/widgets/core/newwidget/Display.svelte',
	validationSchema: string()
});
```

### From widgetManager to widgetStore

```typescript
// OLD: Direct function calls
import { getActiveWidgets } from '@widgets/widgetManager.svelte';
const active = getActiveWidgets();

// NEW: Reactive stores
import { activeWidgets } from '@stores/widgetStore.svelte';
activeWidgets.subscribe(($active) => {
	console.log('Active:', $active);
});
```

---

## Testing Widgets

### Unit Testing

```typescript
import { describe, it, expect } from 'vitest';
import CheckboxWidget from '@widgets/core/checkbox';

describe('Checkbox Widget', () => {
	it('creates field with defaults', () => {
		const field = CheckboxWidget({
			label: 'Test'
		});

		expect(field.label).toBe('Test');
		expect(field.color).toBe('primary');
		expect(field.size).toBe('md');
	});

	it('validates boolean values', async () => {
		const field = CheckboxWidget({ label: 'Test' });
		const schema = field.widget.validationSchema;

		// Valid
		expect(await schema.parse(true)).toBe(true);
		expect(await schema.parse(false)).toBe(false);

		// Invalid
		expect(() => schema.parse('true')).toThrow();
	});
});
```

### Integration Testing

```typescript
import { initializeWidgets } from '@widgets/index';
import { hasWidget } from '@widgets/registry';

describe('Widget System', () => {
	it('loads all core widgets', async () => {
		await initializeWidgets();

		expect(hasWidget('Checkbox')).toBe(true);
		expect(hasWidget('Input')).toBe(true);
		expect(hasWidget('RichText')).toBe(true);
	});
});
```

---

## Troubleshooting

### Widget Not Loading

**Check**:

1. File structure matches pattern: `src/widgets/{core|custom}/{name}/index.ts`
2. Widget exports default function
3. No syntax errors in widget file
4. Dependencies are available

**Debug**:

```typescript
// Check widget functions
import { widgetFunctions } from '@widgets/index';
console.log(Array.from(widgetFunctions().keys()));
```

### Validation Errors

**Check**:

1. Valibot schema is correct
2. Data type matches schema
3. Error messages are clear

**Debug**:

```typescript
import { parse } from 'valibot';
const result = parse(schema, value);
```

### Missing Widget Display

If you see "‚ö†Ô∏è Widget X is missing or disabled":

1. Check widget name spelling
2. Verify widget is registered
3. Check widget activation status
4. Review console for errors

---

## Related Documentation

- [Widget Management System](/docs/dev-guide/widget-management-system.mdx): Store-based widget management
- [Collection Builder](/docs/user-guide/collection-builder.mdx): Using widgets in collections
- [Valibot Documentation](https://valibot.dev/): Validation library
- [mdsvex Documentation](https://mdsvex.pngwn.io/): MDX for Svelte

---

## Summary

The SveltyCMS widget system provides:

- ‚úÖ **Three Pillars Architecture**: Definition, Input, Display separation
- ‚úÖ **Factory Pattern**: Type-safe widget creation with `createWidget()`
- ‚úÖ **Centralized Registry**: Single source of truth for widgets
- ‚úÖ **Valibot Validation**: Declarative, type-safe validation
- ‚úÖ **MDX Documentation**: Per-widget documentation with mdsvex
- ‚úÖ **Auto-Discovery**: Dynamic loading from file system
- ‚úÖ **Dependency Management**: Automatic dependency checking
- ‚úÖ **Type Safety**: Full TypeScript support with generics
- ‚úÖ **Graceful Fallbacks**: MissingWidget component for errors
- ‚úÖ **Performance**: Code splitting and lazy loading

For questions or contributions, see the [Contributing Guide](/docs/contributing/contributing-docs.mdx).
