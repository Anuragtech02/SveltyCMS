/**
 * @file vite.config.ts
 * @description This file contains the Vite configuration for the SvelteKit project, optimized for performance and developer experience.
 * It employs a unified config structure with conditional plugins for the initial setup wizard vs. normal development mode.
 *
 * Key Features:
 * - Centralized path management and logging utilities.
 * - Efficient, direct Hot Module Replacement (HMR) for roles and content structure without fake HTTP requests.
 * - Dynamic compilation of user-defined collections with real-time feedback.
 * - Seamless integration with Paraglide for i18n and svelte-email-tailwind for email templating.
 */

import { paraglideVitePlugin } from '@inlang/paraglide-js';
import { sveltekit } from '@sveltejs/kit/vite';
import { existsSync, promises as fs, readFileSync } from 'fs';
import { builtinModules } from 'module';
import path from 'path';
import svelteEmailTailwind from 'svelte-email-tailwind/vite';
import type { Plugin, UserConfig, ViteDevServer } from 'vite';
import { defineConfig } from 'vite';
import { compile } from './src/utils/compilation/compile';
import { isSetupComplete } from './src/utils/setupCheck';
import { securityCheckPlugin } from './src/utils/vitePluginSecurityCheck';

// --- Constants & Configuration ---

const CWD = process.cwd();
const PKG = JSON.parse(readFileSync(path.resolve(CWD, 'package.json'), 'utf8'));

const paths = {
	configDir: path.resolve(CWD, 'config'),
	privateConfig: path.resolve(CWD, 'config/private.ts'),
	userCollections: path.resolve(CWD, 'config/collections'),
	compiledCollections: path.resolve(CWD, 'compiledCollections'),
	roles: path.resolve(CWD, 'config/roles.ts')
};

// --- Utilities ---

const useColor = process.stdout.isTTY;

/**
 * Standardized logger for build-time scripts, mimicking the main application logger's style.
 */
// Colored tag printed once so message-local color codes render correctly.
const TAG = useColor ? `\x1b[34m[SveltyCMS]\x1b[0m` : `[SveltyCMS]`;
const log = {
	// Info level — tag is blue, message follows (may contain its own color codes)
	info: (message: string) => console.log(`${TAG} ${message}`),
	// Custom success level for clarity in build process
	success: (message: string) => console.log(`${TAG} ${useColor ? `✅ \x1b[32m${message}\x1b[0m` : `✅ ${message}`}`),
	// Corresponds to 'warn' level
	warn: (message: string) => console.warn(`${TAG} ${useColor ? `⚠️ \x1b[33m${message}\x1b[0m` : `⚠️ ${message}`}`),
	// Corresponds to 'error' level
	error: (message: string, error?: unknown) => console.error(`${TAG} ${useColor ? `❌ \x1b[31m${message}\x1b[0m` : `❌ ${message}`}`, error ?? '')
};

/**
 * Ensures collection directories exist and performs an initial compilation if needed.
 * Creates placeholder files if no collections are found to prevent module import errors.
 */
async function initializeCollectionsStructure() {
	await fs.mkdir(paths.userCollections, { recursive: true });
	await fs.mkdir(paths.compiledCollections, { recursive: true });

	const sourceFiles = (await fs.readdir(paths.userCollections, { recursive: true })).filter(
		(file): file is string => typeof file === 'string' && (file.endsWith('.ts') || file.endsWith('.js'))
	);

	if (sourceFiles.length > 0) {
		log.info(`Found \x1b[32m${sourceFiles.length}\x1b[0m collection(s), compiling...`);
		await compile({ userCollections: paths.userCollections, compiledCollections: paths.compiledCollections });
		log.success('Initial collection compilation successful!');
	} else {
		log.info('No user collections found. Creating placeholder structure.');
		const placeholderContent = '// This is a placeholder file generated by Vite.\nexport default {};';
		const collectionsDir = path.resolve(paths.compiledCollections, 'Collections');
		const menuDir = path.resolve(paths.compiledCollections, 'Menu');
		await fs.mkdir(collectionsDir, { recursive: true });
		await fs.mkdir(menuDir, { recursive: true });
		await fs.writeFile(path.resolve(collectionsDir, '_placeholder.js'), placeholderContent);
		await fs.writeFile(path.resolve(menuDir, '_placeholder.js'), placeholderContent);
	}
}

// Force exit on SIGINT to prevent hanging processes
process.on('SIGINT', () => {
	log.warn('\nReceived SIGINT, forcing exit...');
	process.exit(0);
});

// --- Vite Plugins ---

/**
 * A lightweight plugin to handle the initial setup wizard.
 * It creates a default private.ts and opens the setup page in the browser.
 */
function setupWizardPlugin(): Plugin {
	let wasPrivateConfigMissing = false;
	return {
		name: 'svelty-cms-setup-wizard',
		async buildStart() {
			// Check if private config exists before creating it
			wasPrivateConfigMissing = !existsSync(paths.privateConfig);

			// Ensure config directory and default private config exist.
			if (wasPrivateConfigMissing) {
				const content = `
/**
 * @file config/private.ts
 * @description Private configuration file containing essential bootstrap variables.
 * These values are required for the server to start and connect to the database.
 * This file will be populated during the initial setup process.
 */
import { createPrivateConfig } from './types';

export const privateEnv = createPrivateConfig({
    // --- Core Database Connection ---
    DB_TYPE: 'mongodb', // e.g., 'mongodb', 'mariadb'
    DB_HOST: '',
    DB_PORT: 27017,
    DB_NAME: '',
    DB_USER: '',
    DB_PASSWORD: '',

    // --- Connection Behavior ---
    DB_RETRY_ATTEMPTS: 5,
    DB_RETRY_DELAY: 3000, // 3 seconds

    // --- Core Security Keys ---
    JWT_SECRET_KEY: '',
    ENCRYPTION_KEY: '',

    // --- Fundamental Architectural Mode ---
    MULTI_TENANT: false,

    /* * NOTE: All other settings (SMTP, OAuth, etc.) are loaded
     * dynamically from the database after the application starts.
     */
});
`;
				try {
					await fs.mkdir(paths.configDir, { recursive: true });
					await fs.writeFile(paths.privateConfig, content);
					log.info('Created initial private config -> config/private.ts');
				} catch (e) {
					log.error('Failed to provision private config:', e);
				}
			}
			// Ensure collections are ready even in setup mode
			await initializeCollectionsStructure();
		},
		config: () => ({
			define: { __FRESH_INSTALL__: JSON.stringify(wasPrivateConfigMissing) }
		}),
		configureServer(server) {
			const originalListen = server.listen;
			server.listen = function (port?: number, isRestart?: boolean) {
				const result = originalListen.apply(this, [port, isRestart]);
				result.then(() => {
					setTimeout(async () => {
						const address = server.httpServer?.address();
						const resolvedPort = typeof address === 'object' && address ? address.port : 5173;
						const setupUrl = `http://localhost:${resolvedPort}/setup`;

						try {
							const open = (await import('open')).default;
							log.info(`Opening setup wizard in your browser...`);
							await open(setupUrl);
						} catch {
							const coloredUrl = useColor ? `\x1b[34m${setupUrl}\x1b[0m` : setupUrl;
							log.info(`Please open this URL to continue setup: ${coloredUrl}`);
						}
					}, 1000);
				});
				return result;
			};
		}
	};
}

/**
 * Plugin to watch for changes in collections and roles, triggering recompilation
 * and efficient HMR updates.
 */
function cmsWatcherPlugin(): Plugin {
	let compileTimeout: NodeJS.Timeout;

	const handleHmr = async (server: ViteDevServer, file: string) => {
		const isCollectionFile = file.startsWith(paths.userCollections) && /\.(ts|js)$/.test(file);
		const isRolesFile = file === paths.roles;

		if (isCollectionFile) {
			clearTimeout(compileTimeout);
			compileTimeout = setTimeout(async () => {
				log.info(`Collection change detected. Recompiling...`);
				try {
					await compile({ userCollections: paths.userCollections, compiledCollections: paths.compiledCollections });
					log.success('Re-compilation successful!');
					// Directly call the content type generator and trigger an HMR update.
					const { generateContentTypes } = await server.ssrLoadModule('./src/content/vite.ts');
					await generateContentTypes(server);
					log.info('Content structure types regenerated.');
					server.ws.send({ type: 'full-reload', path: '*' });
				} catch (error) {
					log.error(`Error recompiling collections:`, error);
				}
			}, 150); // Debounce changes
		}

		if (isRolesFile) {
			log.info('Roles file changed. Performing HMR...');
			try {
				// Invalidate and reload modules directly for instant, efficient updates.
				const { roles } = await server.ssrLoadModule('./config/roles.ts?t=' + Date.now());
				const { setLoadedRoles } = await server.ssrLoadModule('./src/auth/types.ts?t=' + Date.now());
				setLoadedRoles(roles);
				server.ws.send({ type: 'full-reload', path: '*' });
				log.success('Roles reloaded and client updated.');
			} catch (err) {
				log.error('Error reloading roles.ts:', err);
			}
		}
	};

	return {
		name: 'svelty-cms-watcher',
		enforce: 'post',
		async buildStart() {
			await initializeCollectionsStructure();
		},
		configureServer(server) {
			server.watcher.on('all', (event, file) => {
				if (event === 'add' || event === 'change' || event === 'unlink') {
					handleHmr(server, file);
				}
			});
		}
	};
}

// --- Main Vite Configuration ---

const setupComplete = isSetupComplete();

export default defineConfig((): UserConfig => {
	if (setupComplete) {
		log.success('Setup check passed. Initializing full dev environment...');
	} else {
		log.info('Starting in setup mode...');
	}

	return {
		plugins: [
			// Security check plugin runs first to detect private setting imports
			securityCheckPlugin({
				failOnError: true,
				showWarnings: true,
				extensions: ['.svelte', '.ts', '.js']
			}),
			sveltekit(),
			!setupComplete ? setupWizardPlugin() : cmsWatcherPlugin(),
			paraglideVitePlugin({
				project: './project.inlang',
				outdir: './src/paraglide'
			}),
			svelteEmailTailwind({
				pathToEmailFolder: './src/components/emails'
			})
		],

		server: {
			fs: { allow: ['static', '.'] },
			watch: {
				// Prevent watcher from triggering on generated/sensitive files
				ignored: ['**/config/private.ts', '**/config/private.backup.*.ts', '**/compiledCollections/**']
			}
		},

		resolve: {
			alias: {
				'@root': path.resolve(CWD, './'),
				'@src': path.resolve(CWD, './src'),
				'@components': path.resolve(CWD, './src/components'),
				'@content': path.resolve(CWD, './src/content'),
				'@utils': path.resolve(CWD, './src/utils'),
				'@stores': path.resolve(CWD, './src/stores'),
				'@widgets': path.resolve(CWD, './src/widgets')
			}
		},

		define: {
			__VERSION__: JSON.stringify(PKG.version),
			__FRESH_INSTALL__: false, // Default, may be overridden by setupWizardPlugin
			// SUPERFORMS_LEGACY: true, // Uncomment if using older versions of Superforms
			// `global` polyfill for libraries that expect it (e.g., older crypto libs)
			global: 'globalThis'
		},

		build: {
			target: 'esnext',
			minify: 'esbuild',
			sourcemap: true,
			rollupOptions: {
				onwarn(warning, warn) {
					// Suppress common circular dependency warnings from large libraries
					const suppressedCodes = ['CIRCULAR_DEPENDENCY', 'UNUSED_EXTERNAL_IMPORT'];
					const suppressedSources = ['zod-to-json-schema', 'mongodb', 'mongoose'];

					if (suppressedCodes.includes(warning.code || '') && suppressedSources.some((src) => warning.message.includes(src))) {
						return;
					}
					warn(warning);
				},
				external: [...builtinModules, ...builtinModules.map((m) => `node:${m}`), 'typescript', 'ts-node'],
				output: {
					// Smart chunking for better caching and smaller initial load
					manualChunks: (id: string) => {
						if (id.includes('node_modules')) {
							if (id.includes('@skeletonlabs/skeleton')) return 'skeleton-ui';
							if (id.includes('tiptap')) return 'tiptap-editor';
							if (id.includes('mongodb') || id.includes('mongoose')) return 'database';
							return 'vendor';
						}
					}
				}
			}
		},

		optimizeDeps: {
			exclude: [...builtinModules, ...builtinModules.map((m) => `node:${m}`)],
			include: ['@skeletonlabs/skeleton']
		}
	};
});
