# Widget Activation Cache Bug Fix

**Date:** October 6, 2025  
**Issue:** Widget activation appeared to succeed but didn't persist across page reloads  
**Root Cause:** Cache invalidation bug in widget methods

## Problem Description

When activating a widget through the Widget Manager UI:

1. ✅ The activation API call succeeded
2. ✅ The widget was saved to MongoDB with `isActive: true`
3. ✅ Logs showed "Widget seo activated"
4. ❌ **After page reload, the widget showed as inactive again**

### Investigation Timeline

1. **Initial Hypothesis:** Database update failing
   - Added debug logging to status API
   - Added DatabaseResult handling
   - **Result:** Database was updating correctly!

2. **Database Verification:**

   ```javascript
   db.system_widgets.find({ name: 'seo' }).pretty();
   // Output: isActive: true ✓
   ```

   The widget WAS in the database with correct status!

3. **Root Cause Discovery:**
   - Widget discovery on startup showed "11 active" (should be 12)
   - Frontend fetches active widgets from `/api/widgets/active`
   - This endpoint calls `dbAdapter.widgets.getActiveWidgets()`
   - `getActiveWidgets()` uses cached method `findAllActive()`
   - Cache key: `'widget:active:all'` with 600s TTL
   - **The cache was NEVER being invalidated on widget status updates!**
   - **Deeper issue:** `invalidateCollectionCache('widget:active:all')` used pattern matching (`collection:widget:active:all:*`) which didn't match the actual cache key `'widget:active:all'`!

## The Fix

### Files Modified

#### 1. **`/src/databases/mongodb/methods/widgetMethods.ts`** (Backend Cache Fix)

Changed from pattern-based cache invalidation to direct cache key deletion:

##### `activate()` method

```typescript
// OLD (didn't work - wrong pattern)
await invalidateCollectionCache('widget:active:all');

// NEW (works - direct key deletion)
await cacheService.delete('widget:active:all');
```

##### `deactivate()` method

```typescript
// OLD (didn't work - wrong pattern)
await invalidateCollectionCache('widget:active:all');

// NEW (works - direct key deletion)
await cacheService.delete('widget:active:all');
```

##### `update()` method

```typescript
// OLD (didn't work - wrong pattern)
await invalidateCollectionCache('widget:active:all');

// NEW (works - direct key deletion)
await cacheService.delete('widget:active:all');
```

**Why this fixes it:**

- `invalidateCollectionCache('widget:active:all')` looks for pattern `collection:widget:active:all:*`
- But the actual cache key is just `'widget:active:all'` (no prefix!)
- Pattern matching never found the key, so cache was never cleared
- `cacheService.delete('widget:active:all')` directly deletes the exact key

#### 2. **`/src/routes/(app)/config/widgetManagement/WidgetDashboard.svelte`** (Frontend Refresh Fix)

Changed `toggleWidget()` to force store and UI refresh:

```typescript
// Before: Optimistic local state update
// widget.isActive = newStatus;
// widgets = [...widgets];

// After: Force full refresh from database
const widgetStore = await import('@stores/widgetStore.svelte');
await widgetStore.widgetStoreActions.initializeWidgets(tenantId);
await loadWidgets();
```

This ensures the widget store re-fetches from the database (with fresh cache) and the UI immediately reflects the change.

### Additional Improvements

Added comprehensive debug logging to track widget operations:

1. **`register()` method:**
   - Logs before registration with widget data
   - Logs after successful save
   - Logs errors with context

2. **`update()` method:**
   - Logs before update with data being changed
   - Logs existing widget state
   - Logs after update with new state

3. **`findAll()` method:**
   - Logs query initiation
   - Logs results with count and widget list
   - Logs errors with context

## How the Cache Works

### Cache Key Structure

- `widget:id:{widgetId}` - Individual widget by ID
- **`widget:active:all`** - List of all active widgets (THE CRITICAL ONE!)
- Category: `CacheCategory.WIDGET` - Invalidates all widget-related caches

### Cache Flow

1. **First request:** `findAllActive()` queries DB, caches result for 600s
2. **Subsequent requests:** Returns cached data (fast!)
3. **Widget status changes:** Must invalidate `'widget:active:all'` cache
4. **Next request:** Cache miss, queries DB again with fresh data

## Why This Bug Was Subtle

1. ✅ Database updates worked perfectly
2. ✅ Individual widget cache (`widget:id:xxx`) was invalidated
3. ✅ Category-wide cache was invalidated
4. ❌ **The specific list cache (`widget:active:all`) was NOT invalidated**

The bug only manifested when:

- Activating/deactivating a widget
- Then reloading the page (which fetches from `/api/widgets/active`)
- Within 600 seconds (the cache TTL)

After 600s, the cache would expire naturally and correct data would load.

## Testing the Fix

### Before Fix

```bash
1. Activate 'seo' widget → Success message
2. Reload page → Widget shows as inactive ❌
3. Check database → isActive: true ✓ (confusing!)
4. Wait 10 minutes → Widget finally shows active (cache expired)
```

### After Fix

```bash
1. Activate 'seo' widget → Success message
2. Reload page → Widget shows as active ✓
3. Check database → isActive: true ✓
4. Deactivate → Immediately reflects ✓
```

## Lessons Learned

1. **Cache invalidation is hard** - Classic distributed systems problem
2. **Always invalidate ALL related caches** - Not just the obvious ones
3. **Debug logging is invaluable** - Helped trace the entire flow
4. **Verify database directly** - Separated persistence from display issues
5. **Check frontend data sources** - The bug was in the read path, not write path

## Related Files

- `/src/databases/mongodb/methods/widgetMethods.ts` - Backend cache invalidation fix
- `/src/routes/(app)/config/widgetManagement/WidgetDashboard.svelte` - Frontend refresh fix
- `/src/routes/api/widgets/active/+server.ts` - Endpoint that reads cached data
- `/src/routes/api/widgets/status/+server.ts` - Endpoint that updates widget status
- `/src/routes/api/widgets/list/+server.ts` - Widget Manager list endpoint
- `/src/stores/widgetStore.svelte.ts` - Frontend widget store that caches active widgets
- `/src/databases/mongodb/models/widget.ts` - Widget schema and collection

## Commit Message

```
fix(widgets): invalidate active widgets cache on status changes + force UI refresh

Widget activation was succeeding but not persisting across page reloads
due to stale cache. Two issues were identified:

1. Backend: The `findAllActive()` method caches results with key
   'widget:active:all', but this cache was never invalidated when
   widget status changed.

2. Frontend: Widget Manager used optimistic local state updates instead
   of refetching from database after changes.

Changes:
- Added cache invalidation for 'widget:active:all' to activate(),
  deactivate(), and update() methods in widgetMethods.ts
- Modified WidgetDashboard to force widget store re-initialization
  and full UI refresh after toggling widget status
- Added comprehensive debug logging to track widget operations

Fixes widget activation persistence issue where widgets would revert
to inactive state after page reload despite being saved correctly
in the database.
```

## UPDATE: Multi-Tenant Cache Discovery

**Date:** [Current]
**Critical Finding:** The cache invalidation in `widgetMethods.ts` wasn't working because of **tenant-prefixed cache keys**.

### The Real Root Cause

1. **Cache Storage:** When `withCache()` stores data, it prefixes keys with tenant ID:
   - Input: `'widget:active:all'`
   - Stored as: `'tenant:default:widget:active:all'` (or `'tenant:default-tenant:widget:active:all'`)

2. **Cache Retrieval:** `withCache()` automatically adds tenant prefix when retrieving:
   - Request: `'widget:active:all'` with `tenantId='default'`
   - Looks for: `'tenant:default:widget:active:all'`

3. **Cache Deletion Problem:** `widgetMethods` doesn't have access to tenant context!
   - `cacheService.delete('widget:active:all')` without tenantId
   - Looks for: `'widget:active:all'` (no prefix)
   - Doesn't match: `'tenant:default:widget:active:all'` ❌

### The Working Solution

**Move cache invalidation to the API endpoint** (`/api/widgets/status/+server.ts`) because it has access to `locals.tenantId`:

```typescript
// In /api/widgets/status/+server.ts after database update
await cacheService.delete('widget:active:all', tenantId);
```

This correctly clears `'tenant:{tenantId}:widget:active:all'` because it provides the tenant context.

### Why This Works

- API endpoint has `locals.tenantId` from the request context
- Cache deletion uses the same tenant ID that was used for storage
- Clears the exact cache key that `findAllActive()` will use next time

### Lesson Learned

**Cache invalidation must happen at a layer that has tenant context.** Database methods (`widgetMethods`) operate at a lower level without tenant awareness, while API endpoints have full request context including tenant ID.
