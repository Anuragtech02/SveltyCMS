/**
 * @file: src/routes/api/updateCategories/+server.ts
 * @description: API endpoint for updating the CMS category configuration
 *
 * Features:
 * - Dynamic category update without manual file editing
 * - Error handling and logging for file operations
 */

import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import type { RequestHandler } from './$types';
import { json } from '@sveltejs/kit';

// System Logger
import { logger } from '@utils/logger';

export const POST: RequestHandler = async ({ request }) => {
	try {
		const data = await request.json();

		// If data is undefined, return an error response
		if (!data || !Array.isArray(data)) {
			logger.warn('Invalid or no data provided in the request');
			return new Response('Invalid or no data provided', { status: 400 });
		}

		// Define the path to the categories.ts file
		const categoriesFilePath = path.join(process.cwd(), 'src', 'collections', 'categories.ts');

		const transformedData = data.map((category: any, index: number) => ({
			...category,
			name: category.name,
			icon: category.icon || 'iconoir:category',
			order: typeof category.order === 'number' ? category.order : index * 10 // Preserve existing order or use index-based
		}));

		const newConfigFileContent = generateCategoriesFileContent(transformedData);
		const existingContent = await readExistingConfig(categoriesFilePath);

		if (shouldUpdateConfig(newConfigFileContent, existingContent)) {
			await fs.writeFile(categoriesFilePath, newConfigFileContent);
			logger.info('Categories file updated successfully by API');
			return new Response('Categories file updated successfully', { status: 200 });
		} else {
			logger.info('Categories file does not need an update');
			return new Response(null, { status: 304 });
		}
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		logger.error('Error updating categories file:', { error: errorMessage });
		return json({ success: false, error: `Error updating categories file: ${errorMessage}` }, { status: 500 });
	}
};

// Generate the categories file content
export function generateCategoriesFileContent(data: any[]): string {
	let content = `/**
 * @file src/collections/categories.ts
 * @description Defines the configuration for collection categories including icons and order
 */
// This file is generated by the updateCategories API and will be recreated if altered in GUI

interface CategoryConfig {
    icon: string;
    order: number;
}

// Configuration for collection categories
// Lower order numbers appear first
export const categoryConfig: Record<string, CategoryConfig> = {
`;

	data.forEach((category) => {
		content += `    "${category.name}": {
        icon: "${category.icon || 'iconoir:category'}",
        order: ${category.order}
    },\n`;
	});

	content += '};\n';
	return content;
}

// Reads the existing configuration file
async function readExistingConfig(filePath: string): Promise<string> {
	try {
		return await fs.readFile(filePath, 'utf8');
	} catch (error) {
		if (error.code === 'ENOENT') {
			logger.warn('Categories file does not exist, a new one will be created');
			return '';
		} else {
			logger.error('Error reading the categories file:', error);
			throw error;
		}
	}
}

// Compares the new configuration content with the existing one
function shouldUpdateConfig(newContent: string, existingContent: string): boolean {
	const newContentHash = crypto.createHash('md5').update(newContent).digest('hex');
	const existingContentHash = existingContent ? crypto.createHash('md5').update(existingContent).digest('hex') : '';
	return newContentHash !== existingContentHash;
}
